/*
 * generated by Xtext 2.9.1
 */
package eu.netide.composition.language.generator

import eu.netide.composition.language.composition.CompositionSpecification
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import eu.netide.composition.language.composition.Sequential
import eu.netide.composition.language.composition.Rule
import eu.netide.composition.language.composition.Atom
import eu.netide.composition.language.composition.Parallel
import eu.netide.composition.language.composition.Composition
import eu.netide.composition.language.composition.Branch
import eu.netide.composition.language.composition.Condition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CompositionGenerator extends AbstractGenerator {

	override doGenerate(Resource input, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var composition = input.allContents.toIterable.filter(typeof(CompositionSpecification)).
			findFirst[true] as CompositionSpecification
		var location = new Path(input.URI.toPlatformString(false)).removeFileExtension.lastSegment + ".xml"
		fsa.generateFile(location, composition.compile)
	}

	def compile(CompositionSpecification spec) {

		var result = '''
			<?xml version="1.0" ?>
			<CompositionSpecification xmlns="http://netide.eu/schemas/compositionspecification/v1">
				«IF spec.modules.size > 0»
					<Modules>
						«FOR module : spec.modules»
						<Module id="«module.name»" loaderIdentification="«module.loaderIdentification»" noFenceSupport="«module.noFenceSupport»">
							«FOR cond : module.conditions»
							<CallCondition «
								cond.compile
							»/>
							«ENDFOR»
						</Module>
						«ENDFOR»
					</Modules>
				«ENDIF»
				«IF spec.composition != null»
					<Composition>
						«spec.composition.rule.traverse»
					</Composition>
				«ENDIF»
			</CompositionSpecification>
		'''

		return result
	}
	
	def compile(Condition cond) '''
			«IF !cond.dpids.empty»datapaths="«cond.dpids.join(" ")»" «ENDIF»«
			»«IF !cond.events.empty»events="«cond.events.join(" ")»" «ENDIF»«
			»«IF cond.ethDst != null»ethDst="«cond.ethDst»" «ENDIF»«
			»«IF cond.ethSrc != null»ethSrc="«cond.ethSrc»" «ENDIF»«
			»«IF cond.ethType != null»ethType="«cond.ethType»" «ENDIF»«
			»«IF cond.inPort != 0»inPort="«cond.inPort»" «ENDIF»«
			»«IF cond.ipv4Dst != null»ipv4Dst="«cond.ipv4Dst»" «ENDIF»«
			»«IF cond.ipv4Src != null»ipv4Src="«cond.ipv4Src»" «ENDIF»«
			»«IF cond.ipv6Dst != null»ipv6Dst="«cond.ipv6Dst»" «ENDIF»«
			»«IF cond.ipv6Src != null»ipv6Src="«cond.ipv6Src»" «ENDIF»«
			»«IF cond.ipProto != null»ipProto="«cond.ipProto»" «ENDIF»«
			»«IF cond.tcpDst != 0»tcpDst="«cond.tcpDst»" «ENDIF»«
			»«IF cond.tcpSrc != 0»tcpSrc="«cond.tcpSrc»" «ENDIF»«
			»«IF cond.udpDst != 0»udpDst="«cond.udpDst»" «ENDIF»«
			»«IF cond.udpSrc != 0»udpSrc="«cond.udpSrc»" «ENDIF»«
		»'''

	def String traverse(Rule rule) {
		return '''
			«IF rule instanceof Atom»
				<ModuleCall module="«rule.^val.name»"«IF rule.priority != 0» priority="«rule.priority»"«ENDIF»«
			»«IF rule.allowVetoResult» allowVetoResult="true"«ENDIF»/>
			«ELSEIF rule instanceof Parallel»
				<ParallelCall resolutionPolicy="priority">
					«(rule as Parallel).left.traverse»
					«(rule as Parallel).right.traverse»
				</ParallelCall>
			«ELSEIF rule instanceof Sequential»
				«IF rule.eContainer instanceof Composition»
					«(rule as Sequential).left.traverse»
					«(rule as Sequential).right.traverse»
				«ELSE»
					«(rule as Sequential).left.traverse»
					«(rule as Sequential).right.traverse»
				«ENDIF»
			«ELSEIF rule instanceof Branch»
				<Branch>
					<BranchCondition «(rule as Branch).condition.compile»/>
					<If>
						«(rule as Branch).then.traverse»
					</If>
					«IF (rule as Branch).getElse != null»
					<Else>
						«(rule as Branch).getElse.traverse»
					</Else>
					«ENDIF»
				</Branch>
			«ENDIF»
		'''
	}

}
